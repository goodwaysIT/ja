---
layout: post
title: "レプリケーションの鼓動：Oracle GoldenGateの遅延監視とパフォーマンス診断の詳細解説"
excerpt: "ビジネスサイドから「データ同期が遅い」という苦情が出た際、運用担当者は遅延がどの部分（ソース、ネットワーク、ターゲット？）で発生しているのか把握できず、体系的な特定・診断手法がないため、受動的な対応しかできません。"
date: 2025-08-07 16:00:00 +0800
categories: [Oracle GoldenGate, Performance]
tags: [ogg, lag, latency, performance, monitoring, diagnostics, batchsql, stats]
author: Shane
image: /assets/images/posts/ogg-latency-monitoring-banner.svg
---

データ同期の遅延は、オフィスに仕掛けられた時限爆弾のようなものです。普段は静かですが、ビジネス担当者から「データがまだ来ないのですが？」という詰問と共に持ち込まれると、瞬時に爆発し、あなたを不意打ちします。アラートが鳴り、ビジネスからのプレッシャーが高まると、運用担当者はしばしば受動的な状況に陥ります。遅延は一体どこで発生しているのか？ソース側のExtractが遅いのか、ネットワークにボトルネックがあるのか、それともターゲット側のReplicatの適用が遅いのか？

体系的な診断方法論の欠如は、多くのOGGエンジニアやDBAが共通して抱える問題点です。この記事は、そうした混乱した状況に終止符を打つことを目指し、監視、診断から最適化までを網羅した完全な実践ガイドを提供します。これにより、あなたは受動的な対応者から、データ脈拍を能動的に管理できる専門家へと変貌を遂げるでしょう。

### 第一章：遅延とは何か？—— 正確な定義と全体像の構築

診断に着手する前に、「遅延（Lag）」について正確かつ統一された認識を持つ必要があります。OGGのパイプラインにおいて、遅延は単一の指標ではなく、複数の段階で累積されたものです。各段階の遅延の意味を理解することが、問題特定の礎となります。

![Oracle Data Replication Lantency]({{ '/assets/images/ogg/ogg-data-replication-latency.svg' | relative_url }})

*   **Extract Lag (抽出遅延)**: ソースデータベースでトランザクションがコミット（Commit）された瞬間から、Extractプロセスがその変更をRedoログまたはArchiveログから捕捉し、ローカルのTrailファイルに書き込むまでの時間差を指します。この遅延は主に、Extractプロセスのログ読み取りと処理の効率を反映します。Extractプロセスにとっての遅延とは、Extractがレコードを処理した時間（システムクロックに基づく）と、そのレコードのデータソース内でのタイムスタンプとの差（秒単位）です。

*   **Network Lag (ネットワーク遅延)**: データがソースのTrailファイルから、Data Pumpプロセス（または直接Extractプロセス）を経てネットワークを越えて転送され、ターゲット側のCollectorプロセスによって受信され、リモートのTrailファイルに書き込まれるまでにかかる時間です。この遅延は、ネットワーク帯域、安定性、そしてOGGのネットワークパラメータ（例：`TCPBUFSIZE`）の設定が適切かどうかを評価するための重要な指標です。

*   **Replicat Lag (適用遅延)**: ReplicatプロセスがリモートのTrailファイルからデータ変更を読み取り、それをSQLに解析してターゲットデータベースで正常に実行するまでの時間差を指します。Replicatプロセスにとっての遅延とは、Replicatが最後のレコードを処理した時間（システムクロックに基づく）と、そのレコードのTrailファイル内でのタイムスタンプとの差（秒単位）です。

これら三つが合わさって、エンドツーエンドの総遅延を構成します。ユーザーが「遅い」と不満を述べたとき、あなたの最初の任務は、遅延が主にどの区間で発生しているかを判断することです。


### 第二章：診断ツールボックス - ネイティブコマンド詳解

OGGには強力なコマンドラインツール（GGSCI）が付属しており、これらは遅延を診断するための最も直接的で効果的な武器です。

#### 1. `INFO ALL`：全体概要

これは、ヘルスチェックを行う際の最初のコマンドです。環境内のすべてのOGGプロセス（Manager, Extract, Replicatなど）の状態と遅延情報を表示します。

```bash
GGSCI> INFO ALL

Program     Status      Group       Lag at Chkpt  Time Since Chkpt
-------------------------------------------------------------------
MANAGER     RUNNING
EXTRACT     RUNNING     EXT_ORA     00:00:02      00:00:05
REPLICAT    RUNNING     REP_ORA     00:15:30      00:00:03
```

**キーポイント解説**：

*   **Status**: プロセスが`RUNNING`状態であるかを確認します。`ABENDED`や`STOPPED`であれば、問題は明白です。
*   **Lag at Chkpt**: 最も重要な遅延指標です。**最後のチェックポイント**完了時点で、プロセスが処理しているデータのタイムスタンプとソースでの発生時刻との差を示します。Replicatの`Lag at Chkpt`が数分、数時間と一貫して高い場合、ターゲット側の適用が遅いことを明確に示しています。
*   **Time Since Chkpt**: 最後のチェックポイント更新からどれだけの時間が経過したかを示します。この値が増え続ける場合、プロセスが巨大なトランザクションの処理などでスタックし、チェックポイントを更新できない可能性があります。

#### 2. `LAG [EXTRACT | REPLICAT]`：リアルタイム遅延検出

チェックポイントファイルから古い情報を読み取る`INFO`コマンドとは異なり、`LAG`コマンドはプロセスと直接通信し、よりリアルタイムで正確な遅延情報を取得します。

```bash
GGSCI> LAG REPLICAT REP_ORA

Sending GETLAG request to REPLICAT REP_ORA...
Last record lag: 15 minutes, 32 seconds.
At EOF, no more records to process.
```

`LAG`コマンドは、プロセスが処理中の**最後のレコード**のタイムスタンプと現在のシステム時刻との差を示します。診断中は、`INFO ALL`と`LAG`の結果を組み合わせて、遅延の深刻度とリアルタイム性を相互検証できます。

#### 3. `STATS [EXTRACT | REPLICAT]`：詳細なパフォーマンス分析

特定のプロセス（特にReplicat）がボトルネックであると特定した後、`STATS`コマンドはあなたの「顕微鏡」となります。詳細な操作統計情報を提供し、パフォーマンスのボトルネックを発見するのに役立ちます。

```bash
GGSCI> STATS REPLICAT REP_ORA, TABLE HR.*, TOTAL, DAILY

Sending STATS request to REPLICAT REP_ORA...

Start of Statistics at 2025-08-07 06:30:00.
Replicating from HR.EMPLOYEES to HR.EMPLOYEES:
*** Total statistics since 2025-08-06 10:00:00 ***
        Total inserts:                           50000.00
        Total updates:                          250000.00
        Total deletes:                            1000.00
        Total operations:                       301000.00
Replicating from HR.DEPARTMENTS to HR.DEPARTMENTS:
*** Total statistics since 2025-08-06 10:00:00 ***
        Total inserts:                              10.00
        Total updates:                              25.00
        Total deletes:                               2.00
        Total operations:                           37.00
...
```

**`STATS`レポートから問題を発見する方法**

*   **ホットスポットテーブルの特定**：`TABLE <schema>.*`オプションを使用すると、各テーブルのDML操作数を確認できます。操作の99%が1つか2つのテーブルに集中している場合、問題はこれらの「ホットスポットテーブル」にある可能性が高いです。
*   **操作タイプの評価**：`inserts`, `updates`, `deletes`の比率を観察します。特に主キーやインデックスのないテーブルに対する大量の更新（updates）や、連鎖更新は、通常パフォーマンスキラーです。
*   **処理レートの計算**：`REPORTTRATE`オプション（例：`reportrate min`）を組み合わせることで、分/時間あたりの処理操作数を確認でき、プロセスの処理能力を定量化できます。

#### 4. ログとレポートファイルの分析

*   **.rpt (レポートファイル)**：各OGGプロセスは起動または停止時にレポートファイルを生成します。プロセスが異常終了（Abended）した場合、このファイルが最初の分析対象です。起動パラメータ、マッピング関係、およびエラーの原因に関する詳細情報が記録されています。
*   **ggserr.log (エラーログ)**：これはOGG環境の中央ログファイルで、すべてのプロセスの起動停止、エラー、警告、重要なステータス情報が記録されます。定期的に`ggserr.log`を確認することは、潜在的な問題を積極的に発見するための良い習慣です。Managerのパラメータ（`LAGCRITICALMINUTES`など）を設定して、深刻な遅延イベントを警告としてこのログに書き込むことができます。


### 第三章：遅延の一般的な原因と特定方法

理論とツールを組み合わせて、最も一般的な遅延シナリオとその背後にある「犯人」を分析しましょう。

1.  **ロングランニングトランザクション（Long-running Transaction）**
    *   **症状**: `Time Since Chkpt`が増え続け、`Lag at Chkpt`は安定しているように見えても、実際の総遅延は蓄積しています。ExtractやReplicatは、トランザクション全体がコミットされるのを待ってからチェックポイントを更新します。
    *   **特定**: ソースデータベースで`v$transaction`を照会し、長時間コミットされていないトランザクションを探します。OGGでは、`SEND EXTRACT <ext_name>, SHOWTRANS`を使用して現在処理中のトランザクションリストを表示できます。
    *   **解決策**: 中核となるのは、大きなトランザクションを避けることです。アプリケーション側での改修を推進し、大量のDMLを小バッチに分割してコミットするようにします。

2.  **ターゲット側の低パフォーマンス**
    *   **症状**: Replicatで顕著な`Lag at Chkpt`が発生します。
    *   **特定**:
        *   **インデックス欠損**: `STATS`レポートのホットスポットテーブルを確認し、ターゲット側の対応するテーブルに主キーまたは一意インデックスがあるかを確認します。インデックスなしのフルテーブルスキャンによるUPDATE/DELETEは致命的です。
        *   **データベースのロック/待機イベント**: ターゲットデータベースでAWRレポートを実行するか、待機イベントを照会して、ReplicatセッションがI/O、ロック、CPUなどのリソースを待っているかどうかを確認します。
        *   **フラグメンテーション問題**: テーブルやインデックスの過度な断片化もDMLのパフォーマンスを低下させます。

3.  **ネットワークの不安定性または帯域不足**
    *   **症状**: Data PumpまたはリモートのReplicatで遅延が発生します。`INFO ALL`ではExtractの`Lag at Chkpt`は小さいのに、Replicatの遅延が大きいです。
    *   **特定**: `ping`や`traceroute`などのネットワークツールを使用して、ソースとターゲット間のネットワーク品質をテストします。ネットワーク機器のトラフィックグラフを監視し、帯域が上限に達していないかを確認します。
    *   **解決策**: OGGのネットワークパラメータ（例：`TCPBUFSIZE`, `TCPFLUSHBYTES`）を最適化するか、ネットワークチームに帯域の増設を依頼します。

4.  **不適切な`BATCHSQL`設定**
    *   **症状**: Replicatの遅延は高いですが、ターゲットデータベースの負荷は高くありません。
    *   **特定**: `BATCHSQL`は、類似のSQL文をバッチにまとめて実行することでスループットを向上させます。しかし、小規模なトランザクションや多様なDMLタイプが混在するシナリオでは効果が薄く、過剰なメモリを消費することさえあります。行変更データが大きい場合（例：5000バイト超）、`BATCHSQL`の利点は減少します。Integrated Replicatの場合、トランザクション内の操作数が`EAGER_SIZE`のしきい値を超えると、`BATCHSQL`が有効にならないことがあります。
    *   **解決策**: これはトレードオフです。大量かつ同種のDML（純粋なINSERTなど）には`BATCHSQL`は強力な武器です。そうでなければ、無効にするかパラメータを調整することを検討します。



### 第四章：適切な処方箋 - パフォーマンスチューニング実践

問題を特定したら、的確な対策を講じる必要があります。

#### Replicatのパフォーマンスを最適化するための`BATCHSQL`パラメータ例

大量のINSERTが中心のETLシナリオを扱っていると仮定し、`BATCHSQL`の効果を最大化するためにReplicatのパラメータファイルを次のように設定できます。

```properties
-- replicat parameter file: rep_ora.prm
REPLICAT REP_ORA
USERIDALIAS ogg_tgt DOMAIN OracleGoldenGate
-- BATCHSQLはバッチINSERTのパフォーマンスを大幅に向上させます
BATCHSQL
-- 各バッチで許可される操作数を増やす
BATCHSQL_BATCH_OPS 2000
-- より多くのバッチを収容するためにキュー内のキャッシュ可能バイト数を増やす
BATCHSQL_BYTESPERQUEUE 50000000
-- キュー内のキャッシュ可能操作数を増やす
BATCHSQL_OPSPERQUEUE 10000
```
**注意**: `BATCHSQL`はより多くのメモリを消費します。これらのパラメータを調整する際は、Replicatプロセスのメモリ使用状況を監視し、過剰な消費によるシステム問題を防ぐ必要があります。


### 第五章：予防は治療に勝る - プロアクティブな監視体制の構築

最高レベルの運用とは、未然に問題を防ぐことです。アラートを待つのではなく、プロアクティブな監視体制を構築し、遅延の傾向を継続的に追跡しましょう。

#### シェルスクリプト：遅延傾向の定期的記録

簡単なシェルスクリプトを作成し、`cron`で定期的に実行して`INFO ALL`の出力をログファイルに記録し、遅延の履歴を作成できます。

```bash
#!/bin/bash

# ogg_lag_monitor.sh
# OGGホームとログファイルのパスを定義
OGG_HOME=/u01/app/ogg/19c
LOG_FILE=/var/log/ogg/lag_monitor.log
GGSCI=$OGG_HOME/ggsci

# 現在のタイムスタンプを取得
TIMESTAMP=$(date "+%Y-%m-%d %H:%M:%S")

echo "--- Log Time: $TIMESTAMP ---" >> $LOG_FILE

# ggsciコマンドを実行し、出力をログに追加
$GGSCI << EOF >> $LOG_FILE
INFO ALL
EXIT
EOF

echo "" >> $LOG_FILE
```

このスクリプトを`crontab`に追加し、例えば5分ごとに実行します：
`*/5 * * * * /path/to/ogg_lag_monitor.sh`

さらに一歩進んで、Pythonスクリプトでこれらのログを解析したり、OGGのREST APIを直接呼び出して遅延データをZabbixやPrometheusなどの専門的な監視プラットフォームにプッシュし、グラフィカルな表示とインテリジェントなアラートを実現することもできます。



### まとめ：受動的な火消しから能動的な舵取りへ

OGGの遅延問題に直面したとき、鍵となるのは「ブラックボックス」という認識を打ち破り、明確な診断ワークフローを確立することです。

**OGG遅延診断フローチャート:**

1.  **全体スキャン (`INFO ALL`)**: どのプロセス（Extract, Pump, Replicat）で遅延が発生しているかを迅速に判断します。
2.  **正確な測定 (`LAG`)**: 遅延のリアルタイム性と深刻度を確認します。
3.  **詳細分析 (`STATS`)**: Replicatが遅い場合、どのテーブル、どの操作タイプが原因かを分析します。
4.  **関連分析**:
    *   **ソース側**: 大きなトランザクションを調査します。
    *   **ターゲット側**: インデックス、ロック、AWRレポートを調査します。
    *   **ネットワーク**: 接続性と帯域を調査します。
5.  **最適化の実施**: 的を絞った調整（トランザクションの分割、インデックスの追加、`BATCHSQL`のチューニングなど）を行います。
6.  **継続的な監視**: 自動化された監視スクリプト/システムを確立し、受動的から能動的へ移行します。

覚えておいてください、**監視が土台、診断が鍵、最適化が目標**です。この方法論をマスターすれば、次に誰かがデータ同期の状態について尋ねてきたとき、あなたはもはや受動的な「火消し役」ではなく、「心拍は正常、毎分XX万件の操作を処理中」と自信を持って答えられるプロのデータアーキテクトになっているでしょう。